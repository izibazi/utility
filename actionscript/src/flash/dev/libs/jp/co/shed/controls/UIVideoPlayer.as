package jp.co.shed.controls{	import flash.display.MovieClip;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.SecurityErrorEvent;	import flash.events.IOErrorEvent;	import flash.events.EventDispatcher;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.ObjectEncoding;	import flash.text.TextField;	import flash.utils.Timer;	import jp.co.shed.events.UIVideoPlayerEvent;		/**	 * FLV,MP4の再生を管理するクラス。	 * 	 * @author ishibashi	 */		public class UIVideoPlayer extends EventDispatcher 	{			/*詳細ログを出力するかどうかの真偽値*/		public static var verbose:Boolean = false;		/*ビデオオブジェクト*/		public var video:Video;		private var m_source:String;				/*URI*/		public var uri:String;				/*NetConnectionオブジェクト*/		public var nc:NetConnection;				/*NetStreamオブジェクト*/		public var ns:NetStream;				/*接続中かどうか*/		public var connecting:Boolean = false;				/*バッファ中かどうか*/		public var buffering:Boolean = false;				/*再生中かどうか(一時停止時も再生中であれば、true)*/		public var playing:Boolean = false;				/*一時停止中かどうか*/		public var pausing:Boolean = false;				/*すべてのロードが完了したかどうか*/		public var loaded:Boolean = false;				/*シーク中かどうか(ドラック中も、シーク中と見なす。)*/		public var seeking:Boolean = false;				/*接続が完了したかどうか*/		public var connected:Boolean = false;				/*ムービーが終了したかどうか*/		public var ended:Boolean = false;				/*ミュート中かどうか*/		private var m_mute:Boolean=false;				private var m_volume:Number=1;				private var m_bufferTime:Number=1000;				/*取得したメタデータ*/		public var metaData:Object={};				/*取得したキューポイントデータ*/		public var cuePoint:Object={};				/*取得した画像データ*/		public var imageData:Object={};				/*取得したテキストデータ*/		public var textData:Object={};			/*UIVideoPlayerControllerオブジェクト*/		public var controller:UIVideoPlayerController;				/*メタデータのdurationが、不正の値の場合に、使用する動画の長さ。*/		public var videoTotalTime:Number = 0;				private var timer:Timer;				private var timerInterval:Number = 10;			private var prevTime:Number = 0;				/**		 * コンストラクタ。		 * このオブジェクトを破棄するために、disposeメソッドを実行してください。		 * 		 * @param	video		 * @param	source		 * @param	uri		 * @param	objectEncoding		 */		public function UIVideoPlayer(video:Video , source:String , uri:String = null, objectEncoding:uint = 0) 		{			NetConnection.defaultObjectEncoding = objectEncoding;							this.video = video;			this.video.smoothing=true;			this.uri=uri;			this.controller=controller;						controller = new UIVideoPlayerController(this);						this.source = source;						timer=new Timer(timerInterval);			timer.addEventListener(TimerEvent.TIMER , _check);			timer.start();						log(toString() + "このオブジェクトを破棄するには、必ずdisposeメソッドを実行してください。");		}				private function _check(evt:TimerEvent = null):void		{				//ロード状況の確認。			if (!loaded && playing)			{					loaded = (loadedPercent == 1);				dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.LOAD_PROGRESS));				if(loaded)					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.LOAD_COMPLETE));			}						if (time > 0) 			{				if (!video.visible) 				{					video.visible = true;					}			}			else 			{				if (video.visible) 				{					video.visible = false;				}			}						//再生時で、プレイヘッドが進んでいるならば、強制的にbufferingをfalseにする。			if (ended || (playing && prevTime < time))			{				buffering = false;			}						if (ended || prevTime != time)			{				seeking = false;				}			prevTime = time;			controller.update();		}		/**		 * 接続します。		 */		public function connect():void 		{			if (connecting)			{				log("connect() : 現在接続中です。");				return;			}			else if (connected)			{				log("connect() : 既に接続しています。");				return;			}						nc = new NetConnection();			nc.client = this;			nc.addEventListener(NetStatusEvent.NET_STATUS , _onNetConnectionStatus);			nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR , _onNetConnectionSecurityError);			nc.addEventListener(IOErrorEvent.IO_ERROR , _onNetConnectionIOError);			connected=false;			connecting=true;			buffering = true;			nc.connect(uri);		}				public function onBWDone():void		{					}				private function _onNetConnectionStatus(evt:NetStatusEvent):void 		{	            switch (evt.info.code) {                case "NetConnection.Connect.Success":					connected=true;					connecting=false;										dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_SUCCESS));					if (playing && !pausing)                    	_play();                    break;				case "NetConnection.Connect.Fail":				case "NetConnection.Connect.Rejected":					connected = false;					connecting = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_FAIL,evt));					break;				case "NetConnection.Connect.Closed":					connected = false;					connecting = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_CLOSE,evt));								break;				default:					log("_onNetConnectionStatus() : 想定外のイベントです。　" + evt.info.code);					break;            }		}					private function _onNetConnectionSecurityError(evt:SecurityErrorEvent):void		{			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_SECURITY_ERROR));			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_FAIL,evt));		}					private function _onNetConnectionIOError(evt:IOErrorEvent):void 		{			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_IO_ERROR));			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CONNECT_FAIL,evt));		}						/**		 * 再生します。		 * すでに再生中の場合は、何もしません。		 * また接続中、接続がされていない場合は、接続後、再生します。		 * 		 * @eventType UIVideoPlayerEvent.PLAY		 */		public function play():void		{			if (!ended && playing && !pausing) 			{					log("play() : 現在、"+source+"を再生中です。");				return;			}						playing = true;						if (connecting)			{				log("play() : 現在接続中です。");			}			if (!connected)			{				log("play() : 接続していません。接続します。");				connect();				return;			}			_play();		}				private function _play():void		{			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.WILL_PLAY));				if (ns == null || !pausing) 			{					if (ns != null) 				{					closeStream();					playing = true;				}				pausing = false;				ns = new NetStream(nc);				volume = m_volume;				ns.addEventListener(NetStatusEvent.NET_STATUS, _onNetStreamStatus);				ns.client = this;				video.attachNetStream(ns);				ns.play(source);				controller.play();			}			else if (pausing)			{				resume();			}			else			{				if (ended)				{					seek(0);				}			}			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.PLAY));		}				/**		 * 再生の為の準備をします。		 * 自動再生させない場合に、実行しておくと、ユーザーが再生ボタンを押す間に再生の準備を開始できます。		 */		public function preload():void 		{			play();			pause();		}				/**		 * 停止します。		 * 停止中の場合は、何もしません。		 * 		 * @eventType UIVideoPlayerEvent.WILL_STOP(停止直前)		 * @eventType UIVideoPlayerEvent.STOP(停止後)		 */		public function stop():void		{			if (!playing) return;			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.WILL_STOP));			if (ns) {				ns.pause();				ns.seek(0);							}			playing = false;						pausing = true;			controller.stop();			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STOP));		}				/**		 * 一時停止します。		 * 停止中の場合は、何もしません。		 * 		 * @eventType UIVideoPlayerEvent.PAUSE		 */		public function pause():void		{			if(pausing)return;			pausing = true;			if (playing && ns != null)			{					ns.pause();			}			controller.pause();			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.PAUSE));		}				/**		 * 再開します。		 * 再生中の場合は、何もしません。		 * 		 * @eventType UIVideoPlayerEvent.RESUME		 */		public function resume():void		{			if (!pausing) return;						pausing = false;			if (ns == null) 			{				close();				play();			}			else			{				ns.resume();				controller.resume();				dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.RESUME));			}		}				/**		 * シークします。		 * 		 * @param	time　シーク時間 		 * @eventType UIVideoPlayerEvent.SEEK_START		 */		public function seek(time:Number):void 		{			if (time < 0 || time > duration * 0.99) {				log("seek() : time=" + time + "の値は、不正です。0以上" + duration * 0.99 + "の範囲の値を指定してください。");				return;			}			ended = false;			seeking = true;			ns.seek(time);			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.SEEK_START));		}				/**		 * パーセントを指定してシークします。		 * 		 * @param	percent		 * @eventType UIVideoPlayerEvent.SEEK_START		 */		public function seekByPercent(percent:Number):void		{			seek(percent * duration);		}				private function _onNetStreamStatus(evt:NetStatusEvent):void 		{			//log("_onNetStreamStatus() : evt.info.code=" + evt.info.code);			switch(evt.info.code) {				case "NetStream.Play.StreamNotFound":					buffering = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_NOT_FOUND, evt));					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_FAIL, evt));					break;				case "NetStream.Play.Failed":					buffering = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_FAIL, evt));					break;									case "NetStream.Buffer.Empty":					buffering = true;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.BUFFER_EMPTY, evt));					break;				case "NetStream.Buffer.Full":					buffering = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.BUFFER_FULL, evt));					break;				case "NetStream.Buffer.Flush":					break;									case "NetStream.Play.Start":					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.PLAY_START, evt));					break;				case "NetStream.Play.Stop":					if(loaded)						_onComplete();					break;				case "NetStream.Seek.Notify":					ended = false;					seeking = false;					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.SEEK_COMPLETE, evt));					break;									case "NetStream.Seek.InvalidTime":					if (loaded) {						log("_onNetStreamStatus() : seekに指定した時間が、無効です。先頭にシークします。");						seek(0);					}					dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.SEEK_INVALID_TIME, evt));					break;									default:								log("_onNetStreamStatus() : 想定外のイベントです。　" + evt.info.code);				break;				}		}				private function _onNetStreamSecurityError(evt:SecurityErrorEvent):void		{			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_SECURITY_ERROR));			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_FAIL));		}					private function _onNetStreamIOError(evt:IOErrorEvent):void		{			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_IO_ERROR));			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_FAIL));		}					/**		 * NetStreamを閉じます。		 * NetConnectionを閉じる場合は、close()メソッドを使用してください。		 * 		 * @eventType UIVideoPlayerEvent.STREAM_CLOSE		 */		public function closeStream():void		{			if (ns != null) {				ns.removeEventListener(NetStatusEvent.NET_STATUS, _onNetStreamStatus);				ns.removeEventListener(SecurityErrorEvent.SECURITY_ERROR , _onNetStreamSecurityError);				ns.removeEventListener(IOErrorEvent.IO_ERROR , _onNetStreamIOError);				ns.close();				ns = null;			}					playing = false;			buffering = false;			ended = false;			seeking = false;			pausing = false;			loaded = false;			prevTime = 0;						//videoTotalTime = 0;			metaData = { };			cuePoint = { };			imageData = { };			textData = { };			clearVideo();			controller.close();			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.STREAM_CLOSE));		}				private function closeConnection():void		{			if (nc != null)			{				nc.removeEventListener(NetStatusEvent.NET_STATUS , _onNetConnectionStatus);				nc.removeEventListener(SecurityErrorEvent.SECURITY_ERROR , _onNetConnectionSecurityError);				nc.removeEventListener(IOErrorEvent.IO_ERROR , _onNetConnectionIOError);				nc.close();				nc = null;			}				connecting = false			connected = false		}						private function clearVideo():void		{				video.clear();			video.visible = false;		}				/**		 * NetStream,NetConnectionを閉じます。		 * このクラスが不要になった場合は、disposeメソッドを使用してください。		 * 		 * @eventType UIVideoPlayerEvent.CLEAR		 */		public function close():void		{			closeStream();			closeConnection();			clearVideo();			//timer.stop();			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CLEAR));		}				/**		 * このオブジェクトを破棄します。		 *　これ以後、このオブジェクトを使用することはおすすめしません。		 */		public function dispose():void 		{			close();			timer.stop();			controller.dispose();		}		public function onMetaData(info:Object):void 		{			log("onMetaData : " + getInfo(info));			metaData = info;			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.META_DATA));		}		 		/*		name	キューポイントがビデオファイル内に埋め込まれたときに、キューポイントに指定された名前です。		parameters	このキューポイントに指定された名前と値のペアのストリングの結合配列です。パラメータ名または値には、任意の有効なストリングを使用できます。		time	ビデオファイルの再生時にキューポイントが発生した時間 (秒数) です。		type	到達したキューポイントの種類です。ナビゲーションまたはイベントのいずれかです。		*/		public function onCuePoint(info:Object):void		{			log("onCuePoint : " + getInfo(info));			cuePoint = info;			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.CUE_POINT));		}				public function onImageData(info:Object):void		{			log("onImageData : " + getInfo(info));			imageData=info;			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.IMAGE_DATA));		}				public function onTextData(info:Object):void		{			log("onTextData : " + getInfo(info));			textData=info;			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.TEXT_DATA));		}				public function onXMPData(info:Object):void		{			log("onXMPData : ");		}			public function onPlayStatus(info:Object):void 		{			log("onPlayStatus : " + getInfo(info));				if (info.code == "NetStream.Play.Complete")			{					_onComplete();			}		}				private function _onComplete():void 		{			trace(duration)			if (!ended && (Math.abs(duration - time) < 1))			{				ended = true;				buffering = seeking = false;				controller.complete();				dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.PLAY_COMPLETE));					}		}				public function getInfo(info:Object):String 		{			var s:String = "";			for (var i:* in info) {				s += i + "='"+info[i]+"' ";			}			return s;		}				/**		 * ロード済みバイト数を返却します。		 */		public function get bytesLoaded():Number		{			if (ns == null) return 0;						return ns.bytesLoaded;		}				/**		 * ビデオのトータルバイト数を返却します。		 */		public function get bytesTotal():Number		{			if (ns == null) return 0;			return ns.bytesTotal;		}				/**		 * ロード済みパーセントを返却します。		 * FMSサーバを使用する場合は、1を返却します。		 */		public function get loadedPercent():Number		{			if (uri != null) return 1;						if (bytesTotal == 0) return 0;					 	return bytesLoaded/bytesTotal;		}				/**		 * 現在のプレイヘッド時間を返却します。		 */		public function get time() : Number		{			if (ns == null) return 0;						return ns.time;		}				/**		 * 現在のプレイヘッド時間のパーセントを返却します。		 */		public function get timePercent():Number		{			if(duration==0)return 0;						return Math.min(1, time / duration);		}				/**		 * ビデオの長さを返却します。		 * metadate.durationの値が不正の場合は、videoTotalTimeプロパティの値を返却します。		 *		 */		public function get duration():Number		{			if (isNaN(metaData.duration)) return videoTotalTime;			return metaData.duration;		}				/**		 * ボリュームを返却します。		 */		public function get volume():Number		{			return m_volume;		}				public function set volume(newVol:Number):void		{			m_volume = newVol;			if (!mute)			{				if (ns != null)				{					var trans:SoundTransform = ns.soundTransform;					trans.volume = newVol;					ns.soundTransform = trans;				}				}			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.VOLUME));		}				/**		 * ミュート状態かどうかを返却します。		 */		public function get mute():Boolean		{			return m_mute;		}				public function set mute(isMute:Boolean):void		{			m_mute = isMute;			if (ns != null)			{					var trans:SoundTransform=ns.soundTransform;				trans.volume = mute?0:volume;				ns.soundTransform = trans;			}				controller.mute(m_mute);			dispatchEvent(new UIVideoPlayerEvent(UIVideoPlayerEvent.MUTE));		}				/**		 * バッファ時間を返却します。		 */		public function get bufferTime():Number		{			return m_bufferTime;		}				public function set bufferTime(newVal:Number):void		{			m_bufferTime = newVal;			if (ns != null)				ns.bufferTime = m_bufferTime;		}				/**		 * 現在のバッファの長さを返却します。		 */		public function get bufferLength():Number		{			if (ns == null) return 0;						return ns.bufferLength;		}				/**		 * ビデオのソース名を返却します。		 */		public function get source():String { return m_source; }				public function set source(value:String):void 		{			closeStream();			m_source = value;		}		public function log(value:String):void 		{			if (verbose) {				trace(toString() + value);			}		}				public override function toString():String		{			var s:String = "jp.co.shed.controls.UIVideoPlayer(";			s += "uri='" + uri + "',";			s += "source='" + source + "'," ;			s += "playing='" + playing + "'," ;			s += "pausing='" + pausing + "'," ;			s += "buffering='" + buffering + "'," ;			s += "time='" + time + "'," ;			s += "duration='" + duration + "'," ;			s += "loadedPercent='" + loadedPercent + "'," ;			s += "loaded='" + loaded + "'," ;			s += "ended='" + ended+ "'," ;			s += ")";			return s;		}	}}